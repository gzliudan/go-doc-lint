# 正则表达式注释文档（中文）

🌐 **语言**: [English](REGEX_COMMENTS.md) | [中文](REGEX_COMMENTS_cn.md)

**文档日期**: 2026-02-01
**用途**: 解释 go-doc-lint 中所有复杂正则表达式的含义和用途

---

## 概述

本文档详细说明了 go-doc-lint 中使用的所有关键正则表达式。这些表达式用于：

1. 提取 Go 注释的首词
2. 检测函数和方法声明
3. 识别特殊注释标记（TODO、NOTE 等）

---

## Bash 版本（go-doc-lint.sh）

### 正则表达式 1：提取注释首词

**位置**：go-doc-lint.sh，Perl 代码段中

**正则表达式**：`^//\s+(\S+)`

**模式分解**：

```text
^     - 字符串开始锚点
//    - 字面双斜杠（Go 注释标记）
\s+   - 一个或多个空格字符（空格或制表符）
(\S+) - 捕获组：一个或多个非空格字符（首个单词）
```

**目的**：从 Go 文档注释中提取首个单词

**示例**：

```go
// ReadData 从缓存读取数据
// 正则匹配结果：捕获 "ReadData"

// TODO: 优化此函数
// 正则匹配结果：捕获 "TODO:" （冒号包含在内）

//   多个空格
// 正则匹配结果：捕获 "多个空格"
```

**何时使用**：在处理任何 Go 文件的注释行时

---

### 正则表达式 2a：方法声明检测（带接收器）

**正则表达式**：`^\s*func\s*\([^)]*\)\s*([A-Za-z_][A-Za-z0-9_]*)\s*\(`

**模式分解**：

```text
^\s*              - 行开始，零个或多个空格
func              - 字面关键字 "func"
\s*               - 零个或多个空格
\([^)]*\)       - 括号及其内容（接收器）
                   [^)]* = "除 ) 外的任意字符"
\s*               - 零个或多个空格
([A-Za-z_][A-Za-z0-9_]*)
                  - 捕获组：方法名
                  - [A-Za-z_] = 首字符必须是字母或下划线
                  - [A-Za-z0-9_]* = 后续零个或多个字母数字或下划线
\s*\(             - 零个或多个空格后跟参数开括号
```

**目的**：检测 Go 方法声明（包含接收器的函数）

**示例**：

```go
func (b *Buffer) Read(p []byte) int
// 匹配成功，捕获："Read"

func (接收器 Receiver) 方法名(arg string) error
// 匹配成功，捕获："方法名"

func (b    *Buffer)   Write(data []byte) error
// 匹配成功，捕获："Write" （忽略额外空格）
```

---

### 正则表达式 2b：函数声明检测（包级别）

**正则表达式**：`^\s*func\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(`

**模式分解**：

```text
^\s*              - 行开始，零个或多个空格
func              - 字面关键字 "func"
\s+               - 一个或多个空格（必需！与方法区分）
([A-Za-z_][A-Za-z0-9_]*)
                  - 捕获组：函数名
                  - [A-Za-z_] = 首字符必须是字母或下划线
                  - [A-Za-z0-9_]* = 后续零个或多个字母数字或下划线
\s*\(             - 零个或多个空格后跟参数开括号
```

**目的**：检测包级别的函数声明（没有接收器）

**示例**：

```go
func ReadData(source string) ([]byte, error)
// 匹配成功，捕获："ReadData"

func WriteBuffer(b *Buffer) error
// 匹配成功，捕获："WriteBuffer"

func New() *Handler
// 匹配成功，捕获："New"
```

**关键区别**：

- 方法版本：`func\s*\(` （可选空格）
- 函数版本：`func\s+` （必需空格）

这样可以区分：

- `func (r Receiver) Method()` → 方法（接收器的括号）
- `func Function()` → 函数（参数的括号）

---

### 正则表达式 3：冒号结尾检测

**正则表达式**：`:$`

**模式分解**：

```text
:  - 字面冒号字符
$  - 字符串结束锚点
```

**目的**：识别以冒号结尾的特殊注释标记

**示例**：

```text
"TODO:"     → 匹配 ✓（应排除）
"NOTE:"     → 匹配 ✓（应排除）
"FIXME:"    → 匹配 ✓（应排除）
"BUG:"      → 匹配 ✓（应排除）
"ReadData"  → 不匹配 ✗（应检查）
"TODO"      → 不匹配 ✗（应检查）
```

**使用场景**：不匹配检测的最后一步，过滤掉特殊注释

---

## PowerShell 版本（go-doc-lint.ps1）

### 正则表达式 1a：方法声明检测

**正则表达式**：`^\s*func\s+\([^)]+\)\s+([A-Za-z_]\w*)\s*\(`

**模式分解**（PowerShell 语法）：

```text
^\s*           - 行开始，零个或多个空格
func           - 字面关键字 "func"
\s+            - 一个或多个空格
\([^)]+\)     - 括号及其内容（接收器）
                [^)]+ = "一个或多个非) 字符"
\s+            - 一个或多个空格
([A-Za-z_]\w*) - 捕获组：方法名
                [A-Za-z_] = 首字符必须是字母或下划线
                \w* = 零个或多个单词字符
                       （\w = [A-Za-z0-9_]，同 Bash 版本）
\s*\(          - 零个或多个空格后跟参数开括号
```

**注意**：PowerShell 使用 `\w` 而不是 `[A-Za-z0-9_]`，效果相同

---

### 正则表达式 1b：函数声明检测

**正则表达式**：`^\s*func\s+([A-Za-z_]\w*)\s*\(`

**模式分解**（PowerShell 语法）：

```text
^\s*           - 行开始，零个或多个空格
func           - 字面关键字 "func"
\s+            - 一个或多个空格
([A-Za-z_]\w*) - 捕获组：函数名
                [A-Za-z_] = 首字符必须是字母或下划线
                \w* = 零个或多个单词字符
\s*\(          - 零个或多个空格后跟参数开括号
```

---

### 正则表达式 2：提取注释首词

**正则表达式**：`^//\s+(\S+)`

**说明**：与 Bash 版本完全相同

**模式分解**（PowerShell 语法）：

```text
^    - 字符串开始锚点
//   - 字面双斜杠
\s+  - 一个或多个空格
(\S+) - 捕获组：一个或多个非空格字符
        \S = 非空格（[^ \t\r\n]）
```

---

### 正则表达式 3：冒号结尾检测（PowerShell 版本）

**正则表达式**：`:$`

**说明**：与 Bash 版本完全相同，用于识别特殊注释标记（TODO:、NOTE: 等）

---

## 完整匹配流程

```text
1. 读取 Go 源文件的每一行

2. 检测注释行（使用 ^// 正则）
   ├─ 如果是注释
   │  ├─ 使用 ^//\s+(\S+) 提取首词
   │  └─ 保存到 firstWord 变量
   └─ 如果不是注释，继续

3. 检测函数/方法声明（使用两个正则之一）
   ├─ 使用 ^\s*func\s+\([^)]+\)\s+([A-Za-z_]\w*)\s*\(
   │  └─ 如果匹配 → 提取方法名
   └─ 或使用 ^\s*func\s+([A-Za-z_]\w*)\s*\(
      └─ 如果匹配 → 提取函数名

4. 比较 firstWord 与 funcName
   ├─ 如果相等 → ✓ 匹配（无需报告）
   └─ 如果不相等
      ├─ 检查 firstWord 是否以冒号结尾（使用 :$ 正则）
      │  ├─ 是 → ✓ 是特殊注释（TODO:、NOTE: 等），排除
      │  └─ 否 → ✗ 不匹配！报告此问题
```

---

## 性能考虑

### 正则表达式优化

**已优化的方面**：

1. **捕获组最小化**
   - 仅捕获必要部分（函数名、首词）
   - 避免不必要的括号

2. **字符类使用**
   - `\s` vs `[ \t]` - 前者更高效
   - `\w` vs `[A-Za-z0-9_]` - 效果相同

3. **锚点使用**
   - `^` 和 `$` 限制匹配范围，提高性能

### 典型性能

- 单文件解析：< 100ms
- 1000 个文件项目：~2 秒（Bash）
- 主要开销：磁盘 I/O 而非正则匹配

---

## 常见错误与修复

### 问题 1：未捕获带下划线的函数名

**错误的正则**：`func\s+([A-Za-z0-9]*)`

**问题**：不允许首字符为下划线，无法捕获 `_private` 函数

**正确的正则**：`func\s+([A-Za-z_][A-Za-z0-9_]*)`

**说明**：首字符必须明确允许下划线

---

### 问题 2：无法处理接收器中的复杂类型

**错误的正则**：`func\s*\([^)]*\)` （不匹配嵌套括号）

**示例失败**：`func (m map[string]int) Get()` （方括号内有括号）

**说明**：当前实现通过 `[^)]` 处理，足够大多数情况

**改进方案**：使用更复杂的解析逻辑或 AST 分析

---

### 问题 3：多行函数声明

**当前限制**：仅识别单行声明

**示例**：

```go
func (
    receiver *Receiver
) Method() error
```

**说明**：此注释文档中的正则仅处理单行情况

**改进**：需要状态机处理多行声明

---

## 测试案例

### 应该匹配的模式

```go
// ReadData 从源读取
func ReadData(source string) []byte

// TODO: 优化
func OptimizeMe() {}

//   额外空格的函数
func ExtraSpaces() {}

// _privateFunc 处理内部逻辑
func _privateFunc() error

// MethodName 执行某操作
func (r *Receiver) MethodName() string

// Method123 带数字的方法
func Method123() bool
```

### 不应该匹配的模式

```go
func readData(source string) []byte
// 错：函数名以小写开头（Go 规范），但注释应该匹配

// MissingSpace
func ReadData() // 注释与函数中间有空行

/*
  BlockComment
*/
func BlockFunc()
// 注释：不支持块注释，仅支持 // 行注释
```

---

## 参考资源

### 正则表达式参考

- **锚点**：`^` 开始，`$` 结束
- **量词**：`*` 零或多，`+` 一或多，`?` 零或一
- **字符类**：`\s` 空格，`\S` 非空格，`\w` 单词，`\W` 非单词
- **分组**：`()` 捕获，`(?:)` 非捕获

### Perl vs PowerShell

- 两个版本在正则语法上 99% 兼容
- 差异主要在转义和变量引用方式
- 功能和性能基本相同

---

## 更新历史

| 日期       | 版本  | 变更                   |
| ---------- | ----- | ---------------------- |
| 2026-02-01 | 1.0.0 | 首次添加正则表达式注释 |
